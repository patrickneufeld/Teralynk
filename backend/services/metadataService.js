// File: /backend/services/metadataService.js

const fs = require('fs').promises; // Use async fs methods
const path = require('path');
const { analyzeFileContent } = require('./aiInsightsService'); // AI insights integration
const { recordActivity } = require('./activityLogService');
const { query } = require('./db'); // Database integration

// **Extract basic metadata for a file**
const extractMetadata = async (filePath) => {
    if (!filePath) {
        throw new Error('File path is required.');
    }

    try {
        const stats = await fs.stat(filePath); // Async file stat
        return {
            fileId: path.basename(filePath),
            fileName: path.basename(filePath),
            filePath,
            size: stats.size,
            fileType: path.extname(filePath).slice(1),
            createdAt: stats.birthtime,
            updatedAt: stats.mtime,
        };
    } catch (error) {
        console.error(`Error extracting metadata from file: ${filePath}`, error);
        throw new Error('Unable to extract file metadata.');
    }
};

// **Save or update metadata for a file (using database)**
const saveOrUpdateMetadata = async (filePath, customMetadata = {}) => {
    if (!filePath) {
        throw new Error('File path is required.');
    }

    try {
        const basicMetadata = await extractMetadata(filePath);

        // Analyze file content for AI-generated tags and insights
        const aiInsights = await analyzeFileContent(filePath);
        const autoGeneratedMetadata = {
            tags: aiInsights.tags || [],
            summary: aiInsights.summary || '',
        };

        const metadata = {
            ...basicMetadata,
            ...customMetadata,
            ...autoGeneratedMetadata,
        };

        // Insert or update metadata in the database
        await query(
            `INSERT INTO file_metadata (file_id, file_name, file_path, size, file_type, created_at, updated_at, tags, summary, custom_metadata)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) 
             ON CONFLICT (file_path) DO UPDATE SET 
             file_name = EXCLUDED.file_name, size = EXCLUDED.size, file_type = EXCLUDED.file_type, 
             updated_at = EXCLUDED.updated_at, tags = EXCLUDED.tags, summary = EXCLUDED.summary, 
             custom_metadata = EXCLUDED.custom_metadata`,
            [
                metadata.fileId,
                metadata.fileName,
                metadata.filePath,
                metadata.size,
                metadata.fileType,
                metadata.createdAt,
                metadata.updatedAt,
                metadata.tags,
                metadata.summary,
                JSON.stringify(customMetadata),
            ]
        );

        await recordActivity('system', 'saveOrUpdateMetadata', filePath, { metadata });
        console.log(`Metadata saved or updated for file: ${filePath}`);
        return metadata;
    } catch (error) {
        console.error(`Error saving or updating metadata for file: ${filePath}`, error);
        throw new Error('Unable to save or update metadata.');
    }
};

// **Get metadata for a file (latest version)**
const getMetadata = async (filePath) => {
    try {
        const result = await query(
            'SELECT * FROM file_metadata WHERE file_path = $1 ORDER BY updated_at DESC LIMIT 1',
            [filePath]
        );
        if (result.rows.length === 0) {
            throw new Error('Metadata not found for file.');
        }
        return result.rows[0];
    } catch (error) {
        console.error(`Error retrieving metadata for file: ${filePath}`, error);
        throw new Error('Unable to retrieve metadata.');
    }
};

// **Get metadata history for a file (all versions)**
const getMetadataHistory = async (filePath) => {
    try {
        const result = await query(
            'SELECT * FROM file_metadata WHERE file_path = $1 ORDER BY updated_at DESC',
            [filePath]
        );
        if (result.rows.length === 0) {
            throw new Error('No metadata history found for file.');
        }
        return result.rows;
    } catch (error) {
        console.error(`Error retrieving metadata history for file: ${filePath}`, error);
        throw new Error('Unable to retrieve metadata history.');
    }
};

// **Delete metadata for a file**
const deleteMetadata = async (filePath) => {
    try {
        const result = await query(
            'DELETE FROM file_metadata WHERE file_path = $1 RETURNING file_path',
            [filePath]
        );
        if (result.rows.length === 0) {
            throw new Error('No metadata found for this file to delete.');
        }
        console.log(`Metadata deleted for file: ${filePath}`);
        return { message: 'Metadata deleted successfully.' };
    } catch (error) {
        console.error(`Error deleting metadata for file: ${filePath}`, error);
        throw new Error('Unable to delete metadata.');
    }
};

// **Search metadata based on filters**
const searchMetadata = async (filters) => {
    try {
        const whereClause = Object.keys(filters)
            .map((key) => `${key} = $${Object.keys(filters).indexOf(key) + 1}`)
            .join(' AND ');

        const values = Object.values(filters);

        const result = await query(`SELECT * FROM file_metadata WHERE ${whereClause}`, values);

        if (result.rows.length === 0) {
            throw new Error('No matching metadata found.');
        }

        return result.rows;
    } catch (error) {
        console.error('Error searching metadata:', error);
        throw new Error('Unable to search metadata.');
    }
};

module.exports = {
    extractMetadata,
    saveOrUpdateMetadata,
    getMetadata,
    getMetadataHistory,
    deleteMetadata,
    searchMetadata,
};
